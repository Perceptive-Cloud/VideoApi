require 'media_api'

module VideoApi
# Wrapper class for the REST audio API and other features.
#
class AudioApi < MediaApi

  # Creates an AudioApi object scoped to the given library
  # within the given account.  
  #
  # base_url:: the service base url - see online documentation for this value.
  # company_id:: the account's ID
  # library_id:: the ID of the library within the account to work with
  # license_key:: the license key to use for all authorization requests.  it can be the license key of a user associated with the given library, or an account-wide user.  
  def self.for_library(base_url, company_id, library_id, license_key)
     self.new(MediaApi.create_settings_hash(base_url, company_id, library_id, license_key), true)
  end

  # Creates an AudioApi object scoped to the entire account (i.e. not to a specific library within the account).
  #
  # base_url:: the service base url - see online documentation for this value.
  # company_id:: the account's ID
  # license_key:: the license key to use for all authorization requests.  it must be the license key for an account-level user, not a user assigned to a specific library.  
  #
  # Note: to call the ingest or import methods, you must
  # call AudioApi.for_library instead, or those methods will
  # raise an error.
  #
  def self.for_account(base_url, company_id, license_key)
    self.new(MediaApi.create_settings_hash(base_url, company_id, nil, license_key), false)
  end

  # Creates a new AudioApi object from the given YAML settings file.
  # YAML file should contain the following keys: base_url, company_id, license_key.  It should also contain a library_id key if you want to scope the AudioApi object to a specific library, or ingest/import tracks.
  #
  def self.from_settings_file(path, require_library=false)
    self.new(MediaApi.settings_file_path_to_hash(path), require_library)
  end

  # Create an AudioApi object from the given hash of values.
  # must contain base_url, company_id, and license_key, and
  # optionally library_id.
  def self.from_props(props, require_library=false)
    self.new(props, require_library)
  end

  def initialize(props, require_library=false)
    super(props, require_library)
  end

  # Calls the Track Metadata API, returning the given track's metadata.
  # track_id:: the track's ID
  # format:: an optional string specifying the format of the returned metadata.  If omitted or nil, returns the metadata as a tree of ruby objects generated from the metadata obtained in json format.
  # - 'xml': returns the metadata as an xml string
  # - 'json': returns the metadata as a json string
  # options:: additional optional params to pass on to the API call
  #
  def get_track_metadata(track_id, format=nil, options={})
    params = add_view_auth_param.merge(options)
    structured_data_request("tracks/#{track_id}", params, format) { |track| cleanup_custom_fields(track) }
  end

  # Returns the URL of an RSS feed of the entire account or library's audio tracks.
  # params:: optional hash, adds criteria to the RSS feed URL.  See the online documentation for details.
  #
  # url = api.get_tracks_rss_url {:from => '2009/01/01'}
  #
  def get_tracks_rss_url(params={})
    http.create_url(create_search_sub_url(params, 'rss'))
  end

  # Calls the Audio Search Tracks API, constraining the search to only tracks within the library if one was specified in the constructor.
  #
  # params:: (optional) hash specifying search criteria.  See the online documentation for details.  If omitted, the results will contain all tracks in the library.
  # format:: optional format string.  if omitted, this method returns the metadata as a tree of ruby objects, generated by obtaining the search results in json format and parsing it.
  # - 'xml':: returns the search results as an xml string.
  # - 'json':: returns the search results as a json string.
  #
  # returns a page of Track Search API results.
  #
  # replaces the custom_fields and tags on each track with
  # a Hash containing one key per custom field or tag,
  # instead of the array returned in the JSON results
  #
  def search_tracks(params={}, format=nil)
    search_media(params, format)
  end

  def create_search_sub_url(params, format)
    create_search_media_sub_url("tracks", params, format)
  end

  def get_search_page_media(page)
    page.tracks
  end

  # Calls search_tracks (Track Search API) with the given hash of params, 
  # paginating through the entire result set, 
  # yielding to the provided block with each page of search results
  # as it is obtained.  The provided block can break the loop
  # (stop calling for further pages of results) by returning
  # false.  Any other return value will continue the loop.
  # params:: a hash of params to pass to search_tracks.
  #
  # example:
  # search_tracks_each_page({:query => "balloons"}) do |page|
  #   puts "#{page.tracks.length} more tracks"
  # end
  #
  def search_tracks_each_page(params={}, &block)
    search_media_each_page(params, &block)
  end

  # Calls search_tracks_each_page (Track Search API) 
  # with the given hash of params, 
  # paginating through the entire result set, 
  # yielding to the provided block with each track in each page of results.
  # The provided block can abort the loop by returning
  # false.  Any other return value will continue the loop.
  # params:: a hash of params to pass to search_tracks.
  #
  # example:
  # search_tracks_each({:query => "balloons"}) do |track|
  #   puts "track: #{track.track_id}"
  #   if some_condition(track)
  #     false  # aborts pagination loop
  #   end
  # end
  #
  def search_tracks_each(params={}, &block) 
    search_media_each(params, &block)
  end

  # Calls the Upload API, uploading an audio track file
  # from the local hard drive to your online account, 
  # putting the content into the library you provided in the 
  # constructor of this api object.
  #
  # filename:: the filepath of the audio file to upload to the account.

  # params:: optional hash specifying metadata.  
  #
  # See the online documentation for other allowed params.  
  #
  # To specify an ingest profile, include :ingest_profile 
  # in params.  It will be used in the call to authenticate_for_ingest.
  #
  def upload_track(filename, contributor, params={}, &progress_listener)
    upload_media(filename, contributor, params, &progress_listener)
  end

  def delete_asset(asset_id, track_id)
    audio_api_result do
      http.delete("tracks/#{track_id}/assets/#{asset_id}", add_update_auth_param())
    end
  end

  # Calls the Audio Delete Track API, moving the specified track
  # to the trash.
  def delete_track(track_id)
    audio_api_result do
      http.delete("tracks/#{track_id}", add_update_auth_param)
    end
  end

  # Calls the Update Audio API, modifying the given's track's metadata.
  # track_id:: the ID of the track in question.
  # params:: a hash specifying how to update the track's metadata.  See the online documentation for details.
  #
  # As a convenience, this method will wrap any params in track[],
  # and also allows keyword params, meaning that you can specify each 
  # param key in the hash in one of three ways:
  #
  # {"track[title]" => "my new title"}
  #
  # {"track" => "my new title"}
  #
  # {:track => "my new title"}
  #
  # this method will convert them to the right format for the API call.
  #
  def update_track(track_id, params)
    audio_api_result do
      http.put("tracks/#{track_id}", add_update_auth_param(wrap_update_params(params, "track")))
    end
  end

  # Calls the Audio Update API, setting the given track to visible or hidden.  
  def set_track_visibility(track_id, visible)
    update_track(track_id, {'track[hidden]' => visible ? 'false' : 'true'})
  end

  # Moves the track out of the trash, using a call to the Update Track API,
  # specifyng a blank deleted_at value.
  #
  # Tracks remain in the trash for 7 days.  During that 7-day period,
  # you can call this method to remove the track from the trash ("undelete" it).
  # After the track is permanently deleted (7 days later), this
  # method will raise an error because the track will no longer exist.
  #
  def undelete_track(track_id)
    update_track(track_id, {:deleted_at => ""})
  end

  # NOTE: This method is deprecated.  Instead, use search_tracks, 
  # specifying a value for the 'tags' parameter, which will return the same
  # results as this method.
  #
  # Calls the Tags API, returning the IDs of all tracks tagged with the given tag.  If a library_id was provided in the constructor, only returns results for that library.
  # tag:: the tag to search for
  # format:: optional, specifies the format to return the results in.  If ommitted, this method just returns an Array of matching tracks' IDs.
  # - 'xml': returns the results as an xml string
  # - 'json': return the results as a json string.
  #
  def get_tracks_with_tag(tag, params={}, format=nil)
    get_media_with_tag("tracks", tag, params, format)
  end

  # Calls the Delivery Statistics API.  If a library_id was provided to the constructor, returning only results for that library.
  # params:: a hash specifying the criteria of the statistics report.  See the online documentation for details.
  # format:: an optional string specifying how to return the results.  If omitted, returns them as a ruby object tree, produced by parsing the JSON results.
  # - 'xml': returns the results in xml format.
  # - 'json': returns the results in json format.
  #
  def get_delivery_stats(params, format=nil)
    structured_data_request("#{create_account_library_url}/statistics/track_delivery", 
                           add_view_auth_param(params),
                           format)
  end

  # Calls the Audio Track Statistics API, returning statistics for the given track.  Usage is otherwise identical to get_delivery_stats_for_library.
  # track_id:: the ID of the track in question.
  def get_stats_for_track(track_id, params, format=nil)
    structured_data_request("tracks/#{track_id}/statistics", 
                           add_view_auth_param(params),
                           format)
  end

  # Calls the Audio Ingest Statistics API, returning statistics about track ingesting activity.  If library_id was provided in the constructor, only returns results for that library.  See online documentation for details.  
  # params:: hash specifying the criteria for statistics report.
  # format:: optional string specifying the result format.
  # - if omitted, returns the results as a ruby object tree.
  # - 'xml': returns the results in xml format.
  # - 'json': returns the results in JSON format.
  #
  def get_ingest_stats(params, format=nil)
    structured_data_request("#{create_account_library_url}/statistics/track_ingest", 
                           add_view_auth_param(params),
                           format)
  end

  # Calls the Audio Storage Statistics API, returning statistics about track storage.  If library_id was provided in the constructor, only returns results for that library.  See online documentation for details.  
  # params:: hash specifying the criteria for statistics report.
  # format:: optional string specifying the result format.
  # - if omitted, returns the results as a ruby object tree.
  # - 'xml': returns the results in xml format.
  # - 'json': returns the results in JSON format.
  # - 'csv': returns the tesults in CSV format
  def get_storage_stats(params, format=nil)
    structured_data_request("#{create_account_library_url}/statistics/track_publish/disk_usage", 
                            add_view_auth_param(params),
                            format)
  end

  # Calls the Track Import API, letting you import tracks from a remote webserver into your track account.  
  # xml:: a string of XML specifying the tracks to import.  See the online documentation for an example of this XML string.
  # contributor:: the string to use as the contributor name for the imported tracks.
  # params:: params passed to authenticate_for_ingest.  to specify an ingest_profile, include an 'ingest_profile' or :ingest_profile parameter
  #
  def import_tracks_from_xml_string(xml, contributor, params={})
    import_media_items_from_xml_string(:track, xml, contributor, params)
  end

  # Calls the Track Import API with the XML read from the given file path.
  # path:: the path of the file containing the track import XML.  See the online documentation for details of the XML format.
  # contributor:: the string to use as a the contributor name for the imported tracks.
  # params:: params passed to authenticate_for_ingest.  to specify an ingest_profile, include an 'ingest_profile' or :ingest_profile parameter
  #
  def import_tracks_from_xml_file(path, contributor, params={})
    import_tracks_from_xml_string(File.read(path), contributor, params)
  end

  # Calls the Track Import API with an XML document created from the
  # given array of Hash objects, each representing
  # one of the <entry> elements in the import.
  # nested elements like <customdata> should represented by
  # a nested Hash.
  #
  # for example:
  #
  # import_tracks_from_entries([{:src => "http://www.mywebsite.com/tracks/1",
  #                        :title => "track 1",
  #                        :tags => [{:tag => 'balloons'}]
  #                       },
  #                       {:src => "http://www.mywebsite.com/tracks/2",
  #                        :title => "track 2",
  #                        :customdata => {:my_custom_field => true}
  #                       }
  #                      ])
  #
  # params:: params passed to authenticate_for_ingest.  to specify an ingest_profile, include an 'ingest_profile' or :ingest_profile parameter
  #
  def import_tracks_from_entries(entries, contributor, params={})
    import_tracks_from_xml_string(create_track_import_xml_from_hashes(entries),
                                  contributor,
                                  params)
  end

  # Produces a Track Import API XML string.
  def create_track_import_xml_from_hashes(entries)

    entry_xmls = entries.map {|entry| create_xml_from_value({:entry => entry})}

    '<?xml version="1.0" encoding="UTF-8"?><add><list>' + entry_xmls.join("\n") + '</list></add>'

  end

  # Calls the Audio Track Asset Create API with the given XML string
  def create_track_asset_from_xml_string(track_id, xml)
    audio_api_result do
      http.post("tracks/#{track_id}/assets.xml", 
                add_update_auth_param,
                xml,
                "text/xml")
    end
  end  

  # Calls the Audio Track Asset Create API with the XML string
  # contained in the given filepath.
  def create_track_asset_from_xml_file(track_id, path)
    create_track_asset_from_xml_string(track_id, File.read(path))
  end

  # Calls the Audio Track Asset Create API with an XML string
  # created from the given entry.
  # for example,
  #
  # Example 1: Create a new asset for an existing audio track
  # create_track_asset_from_entry('ABCDE', {:format_name => 'aac_128'})
  #
  # Example 2: Add an asset to an existing audio track
  # create_track_asset_from_entry('ABCDE', {:url => 'http://blahblah.com/12345'})
  #
  # Example 3: Add a remote asset to an existing audio track
  # the_metadata = { :container_type => 'flv', :audio_codec => 'mp3' } And other options, see online docs
  # create_track_asset_from_entry('ABCDE', {:metadata => the_metadata, :process => false, :url => 'http://blahblah.com/12345'})
  #
  def create_track_asset_from_entry(track_id, entry)
    create_track_asset_from_xml_string(track_id, create_asset_xml_from_hash(entry))
  end  

  protected

  def tag_media_type
    "tracks"
  end

  def media_api_result(exception_class=AudioApiException, &block)
    begin
      super(exception_class, &block)
    rescue MediaApiAuthenticationFailedException => e
      raise AudioApiAuthenticationFailedException.new(e)
    rescue AudioApiException => e
      raise
    rescue MediaApiException => e
      raise AudioApiException.new(e)
    end
  end

  def audio_api_result(exception_class=AudioApiException, &block) 
    media_api_result(exception_class, &block)
  end

  def create_search_sub_url(params, format)
    create_search_media_sub_url("tracks", params, format)
  end

  def get_search_page_media(page)
    page.tracks
  end

  def get_track_api_media_object_id(track)
    trac.track_id
  end

end

# Raised whenever an exception condition is encountered when calling AudioApi methods, including exceptions stemming from HttpClient.
class AudioApiException < MediaApiException
  def init(source)
    super(source)
  end
end

# Raised by AudioApi if it fails to obtain a valid authentication signature, most likely because the license key provided wasn't valid, or it has made more than the allowed number of authentication API calls per minute.
class AudioApiAuthenticationFailedException < AudioApiException
  def init(source)
    super(source)
  end
end

end # VideoApi module
